--- plx_hw.c
+++ plx_hw.c
@@ -253,17 +344,26 @@ static inline u32 plx_rid_lut_dma(u8 dma_bus, u8 dma_dev)
  */
 int plx_program_rid_lut_dma(struct plx_device *xdev)
 {
-	if (xdev->run_in_vm) {
-		dev_warn(&xdev->pdev->dev, "Ignore program RID-LUT for DMA\t%s:%u\n", __func__, __LINE__);
-		return 0;
-	}
-
-	if(xdev->dma_ch) {
-		struct pci_dev const*const dma_dev = container_of(xdev->dma_ch->device->dev, struct pci_dev, dev);
-		u8 const dma_bus_number= dma_dev->bus->number;
-		u32 const rid_lut= plx_rid_lut_dma(dma_bus_number, PCI_SLOT(dma_dev->devfn));
+	u8 dma_bus_number;
+	u32 rid_lut;
+	bool kvm;
+
+	if (xdev->dma_ch) {
+		kvm = kvm_check_guest();
+		if (kvm) {
+			dma_bus_number = plx_find_dma_bus_number(xdev->pdev);
+			// dma_slot number can be hardcoded to 0x0 as it will never change to different value due to topology
+			rid_lut = plx_rid_lut_dma(dma_bus_number, 0x0);
+		}
+		else {
+			struct pci_dev const*const dma_dev = container_of(xdev->dma_ch->device->dev, struct pci_dev, dev);
+			dma_bus_number = dma_dev->bus->number;
+			rid_lut = plx_rid_lut_dma(dma_bus_number, PCI_SLOT(dma_dev->devfn));
+		}
+		
 		plx_mmio_write(&xdev->mmio, rid_lut, xdev->reg_base+ PLX_RID_LUT_2_3 );
 		dev_info(&xdev->pdev->dev, "DMA port bus: 0x%X, rid_lut: 0x%X\n", dma_bus_number, rid_lut);
+		
 		return 0;
 	}
 	dev_warn(&xdev->pdev->dev, "Missing DMA\t%s:%u\n", __func__, __LINE__);
@@ -296,17 +396,21 @@ plx_program_rid_lut(struct plx_device *xdev, struct pci_dev *pdev)
 		link_rid_offset = PLX_NT1_RID_LUT_LINK_OFFSET;
 	}
 
-	root_port = plx_find_root_port(pdev);
-	if (!root_port) {
-		dev_err(&pdev->dev, "can't find root port\n");
+	rootinfo = plx_find_rootinfo(pdev);
+	if (rootinfo == 0) {
+		dev_err(&pdev->dev, "can't find PCIe root information\n");
 		return -ENXIO;
 	}
-	root_complex_bus_num = plx_find_root_complex_bus_num(pdev);
-	rid_lut = plx_rid_lut(
-		root_port->bus->number,
-		PCI_SLOT(root_port->devfn),
-		root_complex_bus_num,
-		0);
+
+	root_bus = rootinfo >> 16;
+	rootinfo &= 0xffff;
+	rp_bus = rootinfo >> 8;
+	rp_devfn = rootinfo & 0xff;
+	
+	dev_info(&xdev->pdev->dev, "root_bus:%x, rp_bus:%x, rp_devfn:%x\n", root_bus, rp_bus, rp_devfn);
+
+	rid_lut = plx_rid_lut(rp_bus, rp_devfn, root_bus, 0);
+
 	if (xdev->link_side) {
 		plx_mmio_write(&xdev->mmio, rid_lut, link_rid_offset);
 	} else {
@@ -862,19 +966,19 @@ bool plx_dma_filter(struct dma_chan *chan, void *param)
 		 * PCIe switch shall be used. Due to HW topology, it is at the
 		 * same level, as an upsteram port, two buses above NT port
 		 */
-		dev_dbg (dev, "%s Host side DMA filter looks for DMA at bus 0x%x\n",
+		dev_dbg(dev, "%s Host side DMA filter looks for DMA at bus 0x%x\n",
 			__func__,
 			pdev->bus->parent->parent->number);
 		if (pdev->bus->parent->parent->number == dma_dev->bus->number)
 		{
-			dev_info (dev, "%s Host side DMA filter accepts DMA at bus 0x%x\n",
+			dev_info(dev, "%s Host side DMA filter accepts DMA at bus 0x%x\n",
 				__func__,
 				dma_dev->bus->number);
 			return true;
 		}
 		else
 		{
-			dev_dbg (dev, "%s Host side DMA filter rejects DMA at bus 0x%x\n",
+			dev_dbg(dev, "%s Host side DMA filter rejects DMA at bus 0x%x\n",
 				__func__,
 				dma_dev->bus->number);
 			return false;
